; Namespace management.
(def *ns*)

; Syntax quoting.
(def unquote
  (fn* unquote [_]
    (throw "~ cannot be used outside of syntax quote")))
(def unquote-splicing
  (fn* unquote-splicing [_]
    (throw "~@ cannot be used outside of syntax quote")))

(def type
  (fn* type [o]
    (native/raw "__value = make_box(magic_enum::enum_name(~{ o }->type));")))

; Exceptions
(def ex-info
  (fn* ex-info [msg map]
    {:error msg
     :data map}))

; Relations.
;; Miscellaneous.
(def nil?
  (fn* nil? [o]
    (native/raw "__value = (o == obj::nil::nil_const()) ? ~{ true } : ~{ false }")))

;; Collections.
(def empty?
  (fn* empty? [o]
    (if (nil? o)
      true
      (native/raw "__value = visit_object
                  (
                   [=](auto const typed_o) -> obj::boolean_ptr
                   {
                    using T = typename decltype(typed_o)::value_type;

                    if constexpr(behavior::seqable<T>)
                    { return make_box(typed_o->seq() == nullptr); }
                    else
                    { ~{ (throw (ex-info :not-seqable {:o o})) }; }
                   },
                   ~{ o }
                   );"))))

(def count
  (fn* count [o]
    (if (nil? o)
      0
      (native/raw "__value = make_box(runtime::detail::sequence_length(~{ o }));"))))

(def int
  (fn* int [o]
    (native/raw "__value = make_box(to_int(~{ o }));")))
(def float
  (fn* float [o]
    (native/raw "__value = make_box
                (
                 visit_object
                 (
                  [=](auto const typed_o) -> native_real
                  {
                   using T = typename decltype(typed_o)::value_type;

                   if constexpr(behavior::numberable<T>)
                   { return typed_o->to_real(); }
                   else
                   { ~{ (throw (ex-info :not-a-number {:o o})) }; }
                   },
                  ~{ o }
                  )
                 );")))

; Lists.
; TODO: Can these be removed from the C++ source?
;(def seq
;  (fn* seq [o]
;    (native/raw "__value = visit_object
;                 (
;                   [=](auto const typed_o) -> object_ptr
;                   {
;                     using T = typename decltype(typed_o)::value_type;
;
;                     if constexpr(std::same_as<T, obj::nil>)
;                     { return typed_o; }
;                     else if constexpr(behavior::seqable<T>)
;                     {
;                       auto const &ret(typed_o->seq());
;                       if(!ret)
;                       { return obj::nil::nil_const(); }
;
;                       return ret;
;                     }
;                     else
;                     { ~{ (throw (ex-info :not-seqable {:o o})) }; }
;                   },
;                   ~{ o }
;                 );")))
;(def fresh-seq
;  (fn* fresh-seq [o]
;    (native/raw "__value = visit_object
;                 (
;                   [=](auto const typed_o) -> object_ptr
;                   {
;                     using T = typename decltype(typed_o)::value_type;
;
;                     if constexpr(std::same_as<T, obj::nil>)
;                     { return typed_o; }
;                     else if constexpr(behavior::seqable<T>)
;                     {
;                       auto const &ret(typed_o->seq());
;                       if(!ret)
;                       { return obj::nil::nil_const(); }
;
;                       return ret;
;                     }
;                     else
;                     { ~{ (throw (ex-info :not-seqable {:o o})) }; }
;                   },
;                   ~{ o }
;                 );")))
(def first
  (fn* first [o]
    (native/raw "__value = jank::runtime::first(~{ o });")))
; Returns a fresh seq.
(def next
  (fn* next [o]
    (native/raw "__value = jank::runtime::next(~{ o });")))
(def next-in-place
  (fn* next-in-place [o]
    (native/raw "__value = jank::runtime::next_in_place(~{ o });")))
(def nnext
  (fn* nnext [o]
    (next-in-place (next o))))
(def second
  (fn* second [o]
    (native/raw "__value = jank::runtime::second(~{ o });")))
(def rest
  (fn* rest [o]
    (if (nil? o)
      '()
      (native/raw "__value = visit_object
                   (
                     [=](auto const typed_o) -> object_ptr
                     {
                       using T = typename decltype(typed_o)::value_type;

                       if constexpr(behavior::seqable<T>)
                       {
                         auto const seq(typed_o->seq());
                         if(!seq)
                         { return ~{ '() }; }
                         auto const ret(seq->next());
                         if(ret == nullptr)
                         { return ~{ '() }; }
                         return ret;
                       }
                       else
                       { ~{ (throw (ex-info :not-seqable {:o o})) }; }
                     },
                     ~{ o }
                   );"))))

(def cons
  (fn* cons [head tail]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_tail) -> object_ptr
                   {
                     using T = typename decltype(typed_tail)::value_type;

                     if constexpr(std::same_as<obj::lazy_sequence, T>)
                     { return make_box<jank::runtime::obj::cons>(~{ head }, typed_tail); }
                     else if constexpr(behavior::seqable<T>)
                     { return make_box<jank::runtime::obj::cons>(~{ head }, typed_tail->seq()); }
                     else
                     { ~{ (throw (ex-info :invalid-cons-tail {:type (type tail)})) }; }
                   },
                   ~{ tail }
                 );")))

(def seq?
  (fn* seq? [o]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_tail) -> object_ptr
                   {
                     using T = typename decltype(typed_tail)::value_type;

                     if constexpr(behavior::sequenceable<T>)
                     { return ~{ true }; }
                     else
                     { return ~{ false }; }
                   },
                   ~{ o }
                 );")))

(def list?
  (fn* list? [o]
    ; TODO: Visit and use a behavior for this check instead. It should apply to conses and others.
    (native/raw "__value = make_box(~{ o }->type == object_type::persistent_list);")))

(def list
  (fn* list [& items]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_items) -> object_ptr
                   {
                     using T = typename decltype(typed_items)::value_type;

                     if constexpr(std::same_as<runtime::obj::nil, T>)
                     { return runtime::obj::persistent_list::empty(); }
                     else if constexpr(behavior::seqable<T>)
                     { return runtime::obj::persistent_list::create(typed_items); }
                     else
                     { ~{ (throw (ex-info :invalid-seq {:items items})) }; }
                   },
                   ~{ items }
                 );")))

;; Vectors.
(def vector?
  (fn* vector? [o]
    (native/raw "__value = make_box(~{ o }->type == object_type::persistent_vector);")))

(def vec
  (fn* vec [coll]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_coll) -> object_ptr
                   {
                     using T = typename decltype(typed_coll)::value_type;

                     if constexpr(behavior::seqable<T>)
                     { return jank::runtime::obj::persistent_vector::create(typed_coll); }
                     else
                     { ~{ (throw (ex-info :invalid-seq {:coll coll})) }; }
                   },
                   ~{ coll }
                 );")))

; Returns a persistent vector of the items in vector from
; start (inclusive) to end (exclusive).  If end is not supplied,
; defaults to (count vector). This operation is O(1) and very fast, as
; the resulting vector shares structure with the original and no
; trimming is done.
(def subvec
  (fn* subvec
    ([v start]
     (subvec v start (count v)))
    ([v start end]
     (let* [start (int start)
            end (int end)]
       (native/raw "__value = runtime::subvec(~{ v }, ~{ start }->data, ~{ end }->data);")))))

(def conj)
(def conj
  (fn* conj
    ([]
     [])
    ([coll]
     coll)
    ([coll x]
     (native/raw "__value = jank::runtime::conj(~{ coll }, ~{ x });"))
    ([coll x & args]
     (let* [res (conj coll x)]
       (if (empty? args)
         res
         (recur res (first args) (next args)))))))

; Return the last item in coll, in linear time
(def last
  (fn* last [s]
    (if (next s)
      (recur (next s))
      (first s))))

; Return a seq of all but the last item in coll, in linear time
(def butlast
  (fn* butlast [s]
    (loop* [ret []
            s s]
      (if (next s)
        (recur (conj ret (first s)) (next s))
        (seq ret)))))

;; Maps.
(def map?
  (fn* map? [o]
    (native/raw "__value = make_box
                 (
                   ~{ o }->type == object_type::persistent_array_map
                   || ~{ o }->type == object_type::persistent_hash_map
                 );")))

(def assoc
  (fn* assoc
    ([map key val]
     (native/raw "__value = jank::runtime::assoc(~{ map }, ~{ key }, ~{ val });"))
    ([map key val & kvs]
     (let* [res (assoc map key val)]
       (if kvs
         (if (next kvs)
           (recur res (first kvs) (second kvs) (nnext kvs))
           (throw "assoc expects even number of args after the first"))
         res)))))

;; Strings.
; TODO: Proper version.
(def pr-str)

(def string?
  (fn* string? [o]
    (native/raw "__value = make_box(~{ o }->type == object_type::persistent_string);")))

(def str
  (fn* str
    ([]
     "")
    ([o]
     (native/raw "__value = make_box(runtime::detail::to_string(~{ o }));"))
    ([o & args]
     (native/raw "__value = visit_object
                 (
                   [=](auto const typed_args) -> object_ptr
                   {
                     using T = typename decltype(typed_args)::value_type;

                     if constexpr(behavior::sequenceable<T>)
                     {
                       fmt::memory_buffer buff;
                       buff.reserve(16);
                       runtime::detail::to_string(~{ o }, buff);
                       if(0 < runtime::detail::sequence_length(typed_args))
                       {
                         auto const fresh(typed_args->fresh_seq());
                         runtime::detail::to_string(fresh->first(), buff);
                         for(auto it(fresh->next_in_place()); it != nullptr; it = it->next_in_place())
                         { runtime::detail::to_string(it->first(), buff); }
                       }
                       return make_box<obj::persistent_string>(native_persistent_string{ buff.data(), buff.size() });
                     }
                     else
                     { ~{ (throw (ex-info :invalid-seq {:args args})) }; }
                   },
                   ~{ args }
                 );"))))

;; Symbols.
(def symbol?
  (fn* symbol? [o]
    (native/raw "__value = make_box(~{ o }->type == object_type::symbol)")))

; Relations.
;; Miscellaneous.
(def true?
  (fn* true? [o]
    (native/raw "__value = runtime::detail::equal(~{ o }, ~{ true }) ? ~{ true } : ~{ false }")))
(def false?
  (fn* false? [o]
    (native/raw "__value = runtime::detail::equal(~{ o }, ~{ false }) ? ~{ true } : ~{ false }")))
(def not
  (fn* not [o]
    (native/raw "if(o == obj::nil::nil_const())
                 { __value = ~{ true }; }
                 else
                 { __value = runtime::detail::equal(~{ o }, ~{ false }) ? ~{ true } : ~{ false }; }")))
(def some?
  (fn* some? [o]
    (native/raw "__value = (o == obj::nil::nil_const()) ? ~{ false } : ~{ true }")))


;; Metadata
(def meta
  (fn* meta [o]
    (native/raw "__value = runtime::meta(~{ o });")))
(def with-meta
  (fn* with-meta [o m]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_o) -> object_ptr
                   {
                     using T = typename decltype(typed_o)::value_type;

                     if constexpr(behavior::metadatable<T>)
                     { return typed_o->with_meta(~{ m }); }
                     else
                     { ~{ (throw (ex-info :not-metadatable {:o o
                                                            :type (type o)})) }; }
                   },
                   ~{ o }
                 );")))
(def reset-meta!
  (fn* reset-meta! [o m]
    (native/raw "__value = visit_object
                 (
                   [=](auto const typed_o) -> object_ptr
                   {
                     using T = typename decltype(typed_o)::value_type;

                     if constexpr(behavior::metadatable<T>)
                     {
                       auto const meta(behavior::detail::validate_meta(~{ m }));
                       typed_o->meta = meta;
                       return ~{ m };
                     }
                     else
                     { ~{ (throw (ex-info :not-metadatable {:o o})) }; }
                   },
                   ~{ o }
                 );")))

(def let
  (fn* let [&form &env & decl]
    (cons 'let* decl)))
(reset-meta! (var let) {:macro true})

(def loop
  (fn* loop [&form &env & decl]
    (cons 'loop* decl)))
(reset-meta! (var loop) {:macro true})

(def fn
  (fn* fn [&form &env & decl]
    (with-meta (cons 'fn* decl) (meta &form))))
(reset-meta! (var fn) {:macro true})

; TODO: Private
(def sigs
  (fn* [fdecl]
    (let* [asig (fn* asig [fdecl]
                  (let* [arglist (first fdecl)
                         ;elide implicit macro args
                         arglist (if (native/raw "__value = make_box(runtime::detail::equal(~{ '&form }, ~{ (first arglist) }));")
                                   (subvec arglist 2 (count arglist))
                                   arglist)
                         body (next fdecl)]
                    (if (map? (first body))
                      (if (next body)
                        (with-meta arglist (conj (if (meta arglist)
                                                   (meta arglist)
                                                   {})
                                                 (first body)))
                        arglist)
                      arglist)))]
      (if (seq? (first fdecl))
        (loop* [ret []
                fdecls fdecl]
          (if fdecls
            (recur (conj ret (asig (first fdecls))) (next fdecls))
            (seq ret)))
        (list (asig fdecl))))))

;(defn seq-to-map-for-destructuring
;  "Builds a map from a seq as described in
;  https://clojure.org/reference/special_forms#keyword-arguments"
;  {:added "1.11"}
;  [s]
;  (if (next s)
;    (clojure.lang.PersistentArrayMap/createAsIfByAssoc (to-array s))
;    (if (seq s) (first s) clojure.lang.PersistentArrayMap/EMPTY)))

;; Macros.
(def defn
  (fn* defn [&form &env name & fdecl]
    ;; Note: Cannot delegate this check to def because of the call to (with-meta name ..)
    (if (native/raw "__value = make_box(~{ name }->type != object_type::symbol);")
      (throw "First argument to defn must be a symbol"))
    (let* [m (if (string? (first fdecl))
               {:doc (first fdecl)}
               {})
           fdecl (if (string? (first fdecl))
                   (next fdecl)
                   fdecl)
           m (if (map? (first fdecl))
               (conj m (first fdecl))
               m)
           fdecl (if (map? (first fdecl))
                   (next fdecl)
                   fdecl)
           fdecl (if (vector? (first fdecl))
                   (list fdecl)
                   fdecl)
           m (if (map? (last fdecl))
               (conj m (last fdecl))
               m)
           fdecl (if (map? (last fdecl))
                   (butlast fdecl)
                   fdecl)
           m (conj {:arglists (list 'quote (sigs fdecl))} m)
           m (let* [inline (:inline m)
                    ifn (first inline)
                    iname (second inline)]
               ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)
               (if (if (native/raw "__value = make_box(runtime::detail::equal(~{ 'fn }, ~{ ifn }));")
                     (if (native/raw "__value = make_box(~{ name }->type == object_type::symbol);")
                       false
                       true))
                 ;; inserts the same fn name to the inline fn if it does not have one
                 (assoc m :inline (cons ifn (cons (native/raw "auto const n(expect_object<obj::symbol>(~{ name }));
                                                              __value = make_box<obj::symbol>(n->name + \"__inliner\");")
                                                  (next inline))))
                 m))
           m (conj (if (meta name) (meta name) {}) m)]
      (list 'def (with-meta name m)
            (with-meta (cons `fn fdecl) {:rettag (:tag m)})))))
(reset-meta! (var defn) {:macro true})

(defn macroexpand-1 [form]
  (native/raw "__value = __rt_ctx.macroexpand1(~{ form });"))
(defn macroexpand [form]
  (native/raw "__value = __rt_ctx.macroexpand(~{ form });"))

; Returns a new symbol with a unique name. If a prefix string is
; supplied, the name is prefix# where # is some unique number. If
; prefix is not supplied, the prefix is 'G__'.
(defn gensym
  ([]
   (native/raw "__value = make_box<obj::symbol>(runtime::context::unique_symbol());"))
  ([prefix]
   (native/raw "__value = make_box<obj::symbol>(runtime::context::unique_symbol(runtime::detail::to_string(~{ prefix })));")))

(defn defmacro
  "Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called."
  [&form &env name & args]
  (let [prefix (loop [p (list name) args args]
                 (let [f (first args)]
                   (if (string? f)
                     (recur (cons f p) (next args))
                     (if (map? f)
                       (recur (cons f p) (next args))
                       p))))
        fdecl (loop [fd args]
                (if (string? (first fd))
                  (recur (next fd))
                  (if (map? (first fd))
                    (recur (next fd))
                    fd)))
        fdecl (if (vector? (first fdecl))
                (list fdecl)
                fdecl)
        add-implicit-args (fn [fd]
                            (let [args (first fd)]
                              (cons (vec (cons '&form (cons '&env args))) (next fd))))
        add-args (fn [acc ds]
                   (if (nil? ds)
                     acc
                     (let [d (first ds)]
                       (if (map? d)
                         (conj acc d)
                         (recur (conj acc (add-implicit-args d)) (next ds))))))
        fdecl (seq (add-args [] fdecl))
        decl (loop [p prefix d fdecl]
               (if p
                 (recur (next p) (cons (first p) d))
                 d))]
    (list 'do
          (cons `defn decl)
          (list `reset-meta! (list 'var name) (list 'assoc
                                                    (list 'meta (list 'var name))
                                                    :macro
                                                    true))
          (list 'var name))))
(reset-meta! (var defmacro) {:macro true})

(defmacro defn-
  "Same as defn, yielding non-public def."
  {:added "1.0"}
  [name & decls]
  (cons `defn (cons (with-meta name (assoc (meta name) :private true)) decls)))

(defmacro when [condition & body]
  (list 'if condition
        (cons 'do body)
        nil))

(defmacro when-not [condition & body]
  (list 'if (list 'clojure.core/not condition)
        (cons 'do body)
        nil))

; Takes a set of test/expr pairs. It evaluates each test one at a
; time. If a test returns logical true, cond evaluates and returns
; the value of the corresponding expr and doesn't evaluate any of the
; other tests or exprs. (cond) returns nil.
(defmacro cond [& clauses]
  (when clauses
    (list 'if (first clauses)
          (if (next clauses)
            (second clauses)
            (let [err "cond requires an even number of forms"]
              (list 'throw (list 'clojure.core/ex-info "invalid cond" {:err err}))))
          (cons 'clojure.core/cond (next (next clauses))))))

(defmacro let [args & body]
  (cons 'let* (cons args body)))

; The full `apply` will be defined below, but it requires more helpers to support
; all of its arities.
(defn- apply* [f args]
  (native/raw "__value = runtime::apply_to(~{ f }, ~{ args });"))

(defmacro or
  ([]
   nil)
  ([x]
   x)
  ([x & more]
   (let [x-res (gensym)]
     (list 'clojure.core/let [x-res x]
           (list 'if x-res
                 x-res
                 (cons 'clojure.core/or more))))))

(defmacro and
  ([]
   true)
  ([x]
   x)
  ([x & more]
   (let [x-res (gensym)]
     (list 'clojure.core/let [x-res x]
           (list 'if x-res
                 (cons 'clojure.core/and more)
                 x-res)))))

; Evaluates expr and throws an exception if it does not evaluate to
; logical true.
(defmacro assert
  ([x]
   (when *assert*
     (list 'clojure.core/when-not x
           (list 'throw (list 'clojure.core/ex-info
                              "assertion failed"
                              {:assertion (pr-str x)})))))
  ([x message]
   (when *assert*
     (list 'clojure.core/when-not x
           (list 'throw (list 'clojure.core/ex-info
                              "assertion failed"
                              {:assertion (pr-str x)
                               :message message}))))))

; Ignores body, yields nil
(defmacro comment
  [& body])

;; Transients.

; XXX: Clojure doesn't specify this fn, but I find it useful.
(defn transientable? [o]
  (native/raw "__value = visit_object
               (
                 [=](auto const typed_o) -> object_ptr
                 {
                   using T = typename decltype(typed_o)::value_type;

                   if constexpr(behavior::transientable<T>)
                   { return ~{ true } ; }
                   else
                   { return ~{ false }; }
                 },
                 ~{ o }
               );"))

; Returns a new, transient version of the collection, in constant time.
(defn transient [o]
  (native/raw "__value = visit_object
               (
                 [=](auto const typed_o) -> object_ptr
                 {
                   using T = typename decltype(typed_o)::value_type;

                   if constexpr(behavior::transientable<T>)
                   { return typed_o->to_transient(); }
                   else
                   { ~{ (throw (ex-info :not-transientable {:o o})) }; }
                 },
                 ~{ o }
               );"))

; Returns a new, persistent version of the transient collection, in
; constant time. The transient collection cannot be used after this
; call, any such use will throw an exception.
(defn persistent! [o]
  (native/raw "__value = visit_object
               (
                 [=](auto const typed_o) -> object_ptr
                 {
                   using T = typename decltype(typed_o)::value_type;

                   if constexpr(behavior::persistentable<T>)
                   { return typed_o->to_persistent(); }
                   else
                   { ~{ (throw (ex-info :not-persistentable {:o o})) }; }
                 },
                 ~{ o }
               );"))

(defn conj!
  ([]
   (transient []))
  ([coll]
   coll)
  ([coll x]
   (native/raw "__value = visit_object
                (
                  [=](auto const typed_coll, auto const head) -> object_ptr
                  {
                    using T = typename decltype(typed_coll)::value_type;

                    if constexpr(behavior::consable_in_place<T>)
                    { return typed_coll->cons_in_place(head); }
                    else
                    { ~{ (throw (ex-info :not-consable-in-place {:o coll})) }; }
                   },
                   ~{ coll },
                   ~{ x }
                 );
               ")))

(defn assoc!
  ([coll k v]
   (native/raw "__value = visit_object
                (
                  [=](auto const typed_coll, auto const key, auto const val) -> object_ptr
                  {
                    using T = typename decltype(typed_coll)::value_type;

                    if constexpr(behavior::associatively_writable_in_place<T>)
                    { return typed_coll->assoc_in_place(key, val); }
                    else
                    { ~{ (throw (ex-info :not-associatively_writable_in_place {:o coll})) }; }
                  },
                  ~{ coll },
                  ~{ k },
                  ~{ v }
                );
               "))
  ([coll k v & kvs]
    (let [ret (assoc! coll k v)]
      (if kvs
        (recur ret (first kvs) (second kvs) (nnext kvs))
        ret))))

(defn dissoc!
  ([coll k]
   (native/raw "__value = visit_object
                (
                  [=](auto const typed_coll, auto const key) -> object_ptr
                  {
                    using T = typename decltype(typed_coll)::value_type;

                    if constexpr(behavior::associatively_writable_in_place<T>)
                    { return typed_coll->dissoc_in_place(key); }
                    else
                    { ~{ (throw (ex-info :not-associatively_writable_in_place {:o coll})) }; }
                  },
                  ~{ coll },
                  ~{ k }
                );
               "))
  ([coll k & ks]
    (let [ret (dissoc! coll k)]
      (if ks
        (recur ret (first ks) (next ks))
        ret))))

(defn pop!
  ([coll]
   (native/raw "if( ~{ coll }->type == object_type::transient_vector )
                {
                  auto transient_coll = expect_object<obj::transient_vector>(~{ coll });
                  __value = transient_coll->pop_in_place();
                }
                else
                { ~{ (throw (ex-info :not-transient-vector {:o coll})) }; }
               ")))

(defn disj!
  ([set] set)
  ([set elem]
   (native/raw "if( ~{ set }->type == object_type::transient_set)
                {
                  auto typed_set = expect_object<obj::transient_set>(~{ set });
                  __value = typed_set->disjoin_in_place(~{ elem });
                }
                else
                { ~{ (throw (ex-info :not-transient-set {:o set})) }; }
               "))
  ([set elem & elems]
    (let [ret (disj! set elem)]
      (if elems
        (recur ret (first elems) (next elems))
        ret))))

; Functions.
(defn spread
  {:private true}
  [arglist]
  (cond
    (nil? arglist) nil
    (nil? (next arglist)) (seq (first arglist))
    :else (cons (first arglist) (spread (next arglist)))))

; Creates a new seq containing the items prepended to the rest, the
; last of which will be treated as a sequence.
(defn list*
  ([args]
   (seq args))
  ([a args]
   (cons a args))
  ([a b args]
   (cons a (cons b args)))
  ([a b c args]
   (cons a (cons b (cons c args))))
  ([a b c d & more]
   (cons a (cons b (cons c (cons d (spread more)))))))

; Applies fn f to the argument list formed by prepending intervening arguments to args.
(defn apply
  ([f args]
   (native/raw "__value = runtime::apply_to(~{ f }, ~{ args });"))
  ([f x args]
   (native/raw "__value = runtime::apply_to(~{ f }, ~{ (list* x args) });"))
  ([f x y args]
   (native/raw "__value = runtime::apply_to(~{ f }, ~{ (list* x y args) });"))
  ([f x y z args]
   (native/raw "__value = runtime::apply_to(~{ f }, ~{ (list* x y z args) });"))
  ([f a b c d & args]
   (native/raw "__value = runtime::apply_to(~{ f }, ~{ (cons a (cons b (cons c (cons d (spread args))))) });")))

; Returns a function that takes any number of arguments and returns x.
(defn constantly [x]
  (fn [& args]
    x))

; Returns its argument.
(defn identity [x]
  x)

; Takes a fn f and returns a fn that takes the same arguments as f,
; has the same effects, if any, and returns the opposite truth value.
(defn complement [f]
  (fn
    ([] (not (f)))
    ([x] (not (f x)))
    ([x y] (not (f x y)))
    ([x y & zs] (not (apply f x y zs)))))

; Utils.
; f should be a function of 2 arguments. If val is not supplied,
; returns the result of applying f to the first 2 items in coll, then
; applying f to that result and the 3rd item, etc. If coll contains no
; items, f must accept no arguments as well, and reduce returns the
; result of calling f with no arguments.  If coll has only 1 item, it
; is returned and f is not called.  If val is supplied, returns the
; result of applying f to val and the first item in coll, then
; applying f to that result and the 2nd item, etc. If coll contains no
; items, returns val and f is not called.
; TODO: Support for `reduced`
(defn reduce
  ([f coll]
   (let [s (seq coll)]
     (if s
       (reduce f (first s) (next s))
       (f))))
  ([f val coll]
   (native/raw "__value = visit_object
               (
                [=](auto const typed_coll) -> object_ptr
                {
                 using T = typename decltype(typed_coll)::value_type;

                 if constexpr(behavior::seqable<T>)
                 {
                  object_ptr res{ ~{ val } };
                  for(auto it(typed_coll->fresh_seq()); it != nullptr; it = it->next_in_place())
                  { res = dynamic_call(~{ f }, res, it->first()); }
                  return res;
                  }
                 else
                 { ~{ (throw (ex-info :invalid-seq {:coll coll})) }; }
                 },
                ~{ coll }
                );")))

; Primitives.
;; Arithmetic.
(defn +
  ([]
   0)
  ([x]
   x)
  ([l r]
   (native/raw "__value = runtime::add(~{ l }, ~{ r });"))
  ([l r & args]
   (let [res (native/raw "__value = runtime::add(~{ l }, ~{ r });")]
     (if (empty? args)
       res
       (recur res (first args) (next args))))))
(reset-meta! (var +) {:arities {2 {:supports-unboxed-input? true
                                   :unboxed-output? true}}})

(defn -
  ([x]
   (- 0 x))
  ([l r]
   (native/raw "__value = runtime::sub(~{ l }, ~{ r });"))
  ([l r & args]
   (let [res (native/raw "__value = runtime::sub(~{ l }, ~{ r });")]
     (if (empty? args)
       res
       (recur res (first args) (next args))))))
(reset-meta! (var -) {:arities {2 {:supports-unboxed-input? true
                                   :unboxed-output? true}}})

(defn *
  ([]
   1)
  ([x]
   x)
  ([l r]
   (native/raw "__value = runtime::mul(~{ l }, ~{ r });"))
  ([l r & args]
   (let [res (native/raw "__value = runtime::mul(~{ l }, ~{ r });")]
     (if (empty? args)
       res
       (recur res (first args) (next args))))))
(reset-meta! (var *) {:arities {2 {:supports-unboxed-input? true
                                   :unboxed-output? true}}})

; TODO: Symbol creation for generated names related to instances of this
; will result in a name like `/384`, which gets parsed as `384`. Fix the parsing
; in the symbol string separation fn.
(def /)
(def /
  (fn _SLASH_
    ([x]
     (/ 1 x))
    ([l r]
     (native/raw "__value = runtime::div(~{ l }, ~{ r });"))
    ([l r & args]
     (let [res (native/raw "__value = runtime::div(~{ l }, ~{ r });")]
       (if (empty? args)
         res
         (recur res (first args) (next args)))))))
(reset-meta! (var /) {:arities {2 {:supports-unboxed-input? true
                                   :unboxed-output? true}}})

(defn =
  ([x]
   true)
  ([l r]
   (native/raw "__value = make_box(runtime::detail::equal(~{ l }, ~{ r }));"))
  ([l r & args]
   (if (native/raw "__value = make_box(runtime::detail::equal(~{ l }, ~{ r }));")
     (if (next args)
       (recur r (first args) (next args))
       (native/raw "__value = make_box(runtime::detail::equal(~{ r }, ~{ (first args) }));"))
     false)))

(defn not=
  ([x]
   false)
  ([x y]
   (not (= x y)))
  ([x y & more]
   (not (apply = x y more))))

(defn <
  ([x]
   true)
  ([l r]
   (native/raw "__value = make_box(runtime::lt(~{ l }, ~{ r }));"))
  ([l r & args]
   (if (native/raw "__value = make_box(runtime::lt(~{ l }, ~{ r }));")
     (if (next args)
       (recur r (first args) (next args))
       (native/raw "__value = make_box(runtime::lt(~{ r }, ~{ (first args) }));"))
     false)))
(reset-meta! (var <) {:arities {2 {:supports-unboxed-input? true
                                   :unboxed-output? true}}})

(defn <=
  ([x]
   true)
  ([l r]
   (native/raw "__value = make_box(runtime::lte(~{ l }, ~{ r }));"))
  ([l r & args]
   (if (native/raw "__value = make_box(runtime::lte(~{ l }, ~{ r }));")
     (if (next args)
       (recur r (first args) (next args))
       (native/raw "__value = make_box(runtime::lte(~{ r }, ~{ (first args) }));"))
     false)))
(reset-meta! (var <=) {:arities {2 {:supports-unboxed-input? true
                                    :unboxed-output? true}}})

(defn >
  ([x]
   true)
  ([l r]
   (native/raw "__value = make_box(runtime::lt(~{ r }, ~{ l }));"))
  ([l r & args]
   (if (native/raw "__value = make_box(runtime::lt(~{ r }, ~{ l }));")
     (if (next args)
       (recur r (first args) (next args))
       (native/raw "__value = make_box(runtime::lt(~{ (first args) }, ~{ r }));"))
     false)))
(reset-meta! (var >) {:arities {2 {:supports-unboxed-input? true
                                   :unboxed-output? true}}})

(defn >=
  ([x]
   true)
  ([l r]
   (native/raw "__value = make_box(runtime::lte(~{ r }, ~{ l }));"))
  ([l r & args]
   (if (native/raw "__value = make_box(runtime::lte(~{ r }, ~{ l }));")
     (if (next args)
       (recur r (first args) (next args))
       (native/raw "__value = make_box(runtime::lte(~{ (first args) }, ~{ r }));"))
     false)))
(reset-meta! (var >=) {:arities {2 {:supports-unboxed-input? true
                                    :unboxed-output? true}}})

(defn min
  ([x]
   x)
  ([l r]
   (native/raw "__value = runtime::min(~{ l }, ~{ r });"))
  ([l r & args]
   (let [res (native/raw "__value = runtime::min(~{ l }, ~{ r });")]
     (if (empty? args)
       res
       (recur res (first args) (next args))))))
(reset-meta! (var min) {:arities {2 {:supports-unboxed-input? true
                                     :unboxed-output? true}}})

(defn max
  ([x]
   x)
  ([l r]
   (native/raw "__value = runtime::max(~{ l }, ~{ r });"))
  ([l r & args]
   (let [res (native/raw "__value = runtime::max(~{ l }, ~{ r });")]
     (if (empty? args)
       res
       (recur res (first args) (next args))))))
(reset-meta! (var max) {:arities {2 {:supports-unboxed-input? true
                                     :unboxed-output? true}}})

(defn inc [n]
  (native/raw "__value = runtime::inc(~{ n });"))
(defn dec [n]
  (native/raw "__value = runtime::dec(~{ n });"))

(defn pos? [n]
  (native/raw "__value = make_box(runtime::is_pos(~{ n }));"))
(defn neg? [n]
  (native/raw "__value = make_box(runtime::is_neg(~{ n }));"))
(defn zero? [n]
  (native/raw "__value = make_box(runtime::is_zero(~{ n }));"))

(defn rem [num div]
  (native/raw "__value = runtime::rem(~{ num }, ~{ div });"))
(defn mod [num div]
  (let [m (rem num div)]
    (if (or (zero? m) (= (pos? num) (pos? div)))
      m
      (+ m div))))

;; Numbers.
(defn integer? [o]
  (native/raw "__value = make_box(~{ o }->type == object_type::integer)"))
(defn float? [o]
  (native/raw "__value = make_box(~{ o }->type == object_type::real)"))
(defn boolean? [o]
  (native/raw "__value = make_box(~{ o }->type == object_type::boolean)"))
(defn number? [o]
  (native/raw "__value = make_box
              (
               visit_object
               (
                [=](auto const typed_o) -> native_bool
                {
                 using T = typename decltype(typed_o)::value_type;

                 if constexpr(behavior::numberable<T>)
                 { return true; }
                 else
                 { return false; }
                 },
                ~{ o }
                )
               );"))

(defn even? [o]
  (native/raw "__value = make_box
              (
               visit_object
               (
                [=](auto const typed_o) -> native_bool
                {
                 using T = typename decltype(typed_o)::value_type;

                 if constexpr(std::is_same_v<T, obj::integer>)
                 { return typed_o->data % 2 == 0; }
                 else
                 { ~{ (throw (ex-info :not-an-integer {:o o})) }; }
                 },
                ~{ o }
                )
               );"))
(defn odd? [o]
  (native/raw "__value = make_box
              (
               visit_object
               (
                [=](auto const typed_o) -> native_bool
                {
                 using T = typename decltype(typed_o)::value_type;

                 if constexpr(std::is_same_v<T, obj::integer>)
                 { return typed_o->data % 2 == 1; }
                 else
                 { ~{ (throw (ex-info :not-an-integer {:o o})) }; }
                 },
                ~{ o }
                )
               );"))

;; Random.
(defn rand
  ([]
   (native/raw "__value = make_box(jank::runtime::rand());"))
  ([n]
   (* (rand) n)))
(reset-meta! (var rand) {:arities {0 {:supports-unboxed-input? true
                                      :unboxed-output? true}}})

; Strings.

; TODO: Proper version.
(def pr-str str)

(defn subs
  ([s start]
   (native/raw "__value = visit_object
               (
                 [=](auto const typed_s) -> obj::persistent_string_ptr
                 {
                   using T = typename decltype(typed_s)::value_type;

                   if constexpr(std::is_same_v<T, obj::persistent_string>)
                   { return typed_s->substring(to_int(~{ start })).expect_ok(); }
                   else
                   { ~{ (throw (ex-info :not-a-string {:s s})) }; }
                 },
                 ~{ s }
               );"))
  ([s start end]
   (native/raw "__value = visit_object
               (
                 [=](auto const typed_s) -> obj::persistent_string_ptr
                 {
                   using T = typename decltype(typed_s)::value_type;

                   if constexpr(std::is_same_v<T, obj::persistent_string>)
                   { return typed_s->substring(to_int(~{ start }), to_int(~{ end })).expect_ok(); }
                   else
                   { ~{ (throw (ex-info :not-a-string {:s s})) }; }
                 },
                 ~{ s }
               );")))

(defn- first-index-of [s c]
  (native/raw "__value = make_box
              (
                visit_object
                (
                  [=](auto const typed_s) -> native_integer
                  {
                    using T = typename decltype(typed_s)::value_type;

                    if constexpr(std::is_same_v<T, obj::persistent_string>)
                    { return typed_s->first_index_of(~{ c }); }
                    else
                    { ~{ (throw (ex-info :not-a-string {:s s})) }; }
                  },
                  ~{ s }
                )
              );"))
(defn- last-index-of [s c]
  (native/raw "__value = make_box
              (
                visit_object
                (
                  [=](auto const typed_s) -> native_integer
                  {
                    using T = typename decltype(typed_s)::value_type;

                    if constexpr(std::is_same_v<T, obj::persistent_string>)
                    { return typed_s->last_index_of(~{ c }); }
                    else
                    { ~{ (throw (ex-info :not-a-string {:s s})) }; }
                  },
                  ~{ s }
                )
              );"))

;; Sequences (again).
(defn sequential? [o]
  (native/raw "__value = make_box
              (
               visit_object
               (
                [=](auto const typed_o) -> native_bool
                {
                 using T = typename decltype(typed_o)::value_type;

                 if constexpr(behavior::sequenceable<T>)
                 { return true; }
                 else
                 { return false; }
                 },
                ~{ o }
                )
               );"))

(defn reverse [coll]
  (reduce conj () coll))

; XXX: This will be redefined later on, to be lazy.
(defn concat
  ([]
   '())
  ([x]
   (seq x))
  ([x y]
   (reduce (fn [acc e]
             (cons e acc))
           y
           (reverse x)))
  ([x y & zs]
   (let [r (concat x y)]
     (if (empty? zs)
       r
       (recur r (first zs) (rest zs))))))

; Returns true if (pred x) is logical true for every x in coll, else false.
(defn every? [pred coll]
  (cond
    (nil? (seq coll)) true
    (pred (first coll)) (recur pred (next coll))
    :else false))

; Creates a new vector containing the args.
(defn vector
  ([]
   [])
  ([a]
   [a])
  ([a b]
   [a b])
  ([a b c]
   [a b c])
  ([a b c d]
   [a b c d])
	([a b c d e]
   [a b c d e])
	([a b c d e f]
   [a b c d e f])
  ([a b c d e f & args]
   ; TODO: LazilyPersistentVector
   (vec (concat [a b c d e f] args))))

(defn lazy-seq* [fun]
  (native/raw "__value = make_box<obj::lazy_sequence>(~{ fun });"))

; Takes a body of expressions that returns an ISeq or nil, and yields
; a Seqable object that will invoke the body only the first time seq
; is called, and will cache the result and return it on all subsequent
; seq calls. See also - realized?
(defmacro lazy-seq [& body]
  `(lazy-seq* (fn [] ~@body)))

; Repeatedly executes body (presumably for side-effects) with
; bindings and filtering as provided by `for`.  Does not retain
; the head of the sequence. Returns nil.
; TODO: Support more bindings
; TODO: Support `for` functionality
(defmacro doseq [bindings & body]
  (let [arg (first bindings)
        s (second bindings)]
    (list 'clojure.core/reduce (concat (list 'clojure.core/fn ['_ arg])
                                       body
                                       [nil])
          nil
          s)))

; Returns a lazy seq representing the concatenation of the elements in the supplied colls.
(defn concat
  ([] (lazy-seq nil))
  ([x] (lazy-seq x))
  ([x y]
   (lazy-seq
     (let [s (seq x)]
       (if s
         ; TODO: Chunking
         (cons (first s) (concat (rest s) y))
         y))))
  ([x y & zs]
   (let [cat (fn cat [xys zs]
               (lazy-seq
                 (let [xys (seq xys)]
                   (if xys
                     ; TODO: Chunking
                     (cons (first xys) (cat (rest xys) zs))
                     (when zs
                       (cat (first zs) (next zs)))))))]
     (cat (concat x y) zs))))

; Returns the first logical true value of (pred x) for any x in coll,
; else nil.  One common idiom is to use a set as pred, for example
; this will return :fred if :fred is in the sequence, otherwise nil:
; (some #{:fred} coll)
(defn some [pred coll]
  (let [s (seq coll)]
    (when s
      (or (pred (first s)) (recur pred (next s))))))

(defn not-any? [pred coll]
  (not (some pred coll)))

; Threads the expr through the forms. Inserts x as the
; second item in the first form, making a list of it if it is not a
; list already. If there are more forms, inserts the first form as the
; second item in second form, etc.
(defmacro -> [x & forms]
  (loop* [x x
          forms forms]
    (if forms
      (let [form (first forms)
            threaded (if (seq? form)
                       (with-meta `(~(first form) ~x ~@(next form)) (meta form))
                       (list form x))]
        (recur threaded (next forms)))
      x)))

; Threads the expr through the forms. Inserts x as the
; last item in the first form, making a list of it if it is not a
; list already. If there are more forms, inserts the first form as the
; last item in second form, etc.
(defmacro ->> [x & forms]
  (loop* [x x
          forms forms]
    (if forms
      (let [form (first forms)
            threaded (if (seq? form)
                       (with-meta `(~(first form) ~@(next form)  ~x) (meta form))
                       (list form x))]
        (recur threaded (next forms)))
      x)))

;; Maps.
(defn hash-map
  ([]
   ; XXX: Clojure returns an array map for this arity, but that sucks.
   (native/raw "__value = obj::persistent_hash_map::empty();"))
  ([& kvs]
   (native/raw "__value = obj::persistent_hash_map::create_from_seq(~{ kvs });")))

(defn keys [m]
  ; TODO: Use a proper key seq instead.
  (reduce (fn [acc kv]
            (conj acc (first kv)))
          []
          m))

(defn vals [m]
  ; TODO: Use a proper val seq instead.
  (reduce (fn [acc kv]
            (conj acc (second kv)))
          []
          m))

(defn get
  ([m k]
   (native/raw "__value = jank::runtime::get(~{ m }, ~{ k });"))
  ([m k fallback]
   (native/raw "__value = jank::runtime::get(~{ m }, ~{ k }, ~{ fallback });")))
(defn get-in
  ([m ks]
   (native/raw "__value = jank::runtime::get_in(~{ m }, ~{ ks });"))
  ([m ks fallback]
   (native/raw "__value = jank::runtime::get_in(~{ m }, ~{ ks }, ~{ fallback });")))

(defn dissoc
  "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,
  that does not contain a mapping for key(s)."
  ([m]
   m)
  ([m k]
   (native/raw "__value = jank::runtime::dissoc(~{ m }, ~{ k });"))
  ([m k & ks]
   (let* [ret (dissoc m k)]
     (if ks
       (recur ret (first ks) (next ks))
       ret))))

; Returns true if key is present in the given collection, otherwise
; returns false.  Note that for numerically indexed collections like
; vectors and Java arrays, this tests if the numeric key is within the
; range of indexes. 'contains?' operates constant or logarithmic time;
; it will not perform a linear search for a value.  See also 'some'.
(defn contains? [coll k]
  (native/raw "__value = make_box(jank::runtime::contains(~{ coll }, ~{ k }));"))

; Returns the map entry for key, or nil if key not present.
(defn find [coll k]
  (native/raw "__value = jank::runtime::find(~{ coll }, ~{ k });"))

; Returns a map containing only those entries in map whose key is in keys
(defn select-keys [m ks]
  (reduce (fn [acc k]
            (let [e (native/raw "__value = jank::runtime::find(~{ m }, ~{ k });")]
              (if e
                (conj acc e)
                acc)))
          {}
          ks))

; Returns a map with the keys mapped to the corresponding vals.
(defn zipmap [keys vals]
  (loop* [map (transient (hash-map))
          ks (seq keys)
          vs (seq vals)]
    (if (and ks vs)
      (recur (assoc! map (first ks) (first vs))
             (next ks)
             (next vs))
      (persistent! map))))

;; Sets.
(defn set? [o]
  (native/raw "__value = make_box(~{ o }->type == object_type::persistent_set);"))

; Returns a set of the distinct elements of coll.
(defn set [coll]
  (if (set? coll)
    (with-meta coll nil)
    ; TODO: Transient
    (reduce (fn [acc e]
              (conj acc e))
            (native/raw "__value = make_box<obj::persistent_set>();")
            coll)))

;; Other.
(defn hash [o]
  (native/raw "__value = make_box(hash::visit(~{ o }));"))

(defn name [o]
  (if (string? o)
    o
    (native/raw "__value = make_box
                (
                  visit_object
                  (
                    [=](auto const typed_o) -> native_persistent_string
                    {
                      using T = typename decltype(typed_o)::value_type;

                      if constexpr(behavior::nameable<T>)
                      { return typed_o->get_name(); }
                      else
                      { ~{ (throw (ex-info :not-nameable {:o o})) }; }
                    },
                    ~{ o }
                  )
                );")))

(defn namespace [o]
  (native/raw "__value = make_box
              (
                visit_object
                (
                  [=](auto const typed_o) -> native_persistent_string
                  {
                    using T = typename decltype(typed_o)::value_type;

                    if constexpr(behavior::nameable<T>)
                    { return typed_o->get_namespace(); }
                    else
                    { ~{ (throw (ex-info :not-nameable {:o o})) }; }
                  },
                  ~{ o }
                )
              );"))

;; Sequences.
; This is defined to be lazy later on.
(defn drop
  ([n coll]
   (let [step (fn [n acc]
                (let [s (seq acc)]
                  (if (and (pos? n) s)
                    (recur (dec n) (rest s))
                    acc)))]
     (step n coll))))

; Returns a lazy seq of every nth item in coll.  Returns a stateful
; transducer when no collection is provided.
(defn take-nth
  ; TODO: transducer
  ([n coll]
   ; TODO: lazy-seq
   (let [f (fn [acc coll]
             (if (seq coll)
               (let [remaining (drop n coll)]
                 (if (seq remaining)
                   (recur (conj acc (first remaining)) remaining)
                   acc))
               acc))]
     (if (seq coll)
       (f [(first coll)] (rest coll))
       '()))))

;; Vars.
(defn var? [o]
  (native/raw "__value = make_box(~{ o }->type == object_type::var)"))

; TODO: Make this private.
(defmacro assert-macro-args
  [& pairs]
  (list 'do
        (list 'clojure.core/when-not (first pairs)
              ; TODO: No need for ex-info, if we had a simpler exception type
              (list 'throw (list 'clojure.core/ex-info
                                 (list 'clojure.core/str
                                       '&form
                                       " requires "
                                       (second pairs)
                                       " in "
                                       'clojure.core/*ns*
                                       ":"
                                       (:line (meta '&form)))
                                 {})))
        (let [more (next (next pairs))]
          (when more
            (list* 'clojure.core/assert-macro-args more)))))

; bindings => binding-form test
;
; If test is true, evaluates then with binding-form bound to the value of
; test, if not, yields else
; TODO: Macro arities
;(defmacro if-let
;  ([bindings then]
;   `(if-let ~bindings ~then nil))
;  ([bindings then else & oldform]
;   (assert-macro-args
;     (vector? bindings) "a vector for its binding"
;     (nil? oldform) "1 or 2 forms after binding vector"
;     (= 2 (count bindings)) "exactly 2 forms in binding vector")
;   (let [form (bindings 0) tst (bindings 1)]
;     `(let [temp# ~tst]
;        (if temp#
;          (let [~form temp#]
;            ~then)
;          ~else)))))

; bindings => binding-form test
;
; When test is true, evaluates body with binding-form bound to the value of test
(defmacro when-let [bindings & body]
  (assert-macro-args
    (vector? bindings) "a vector for its binding"
    (= 2 (count bindings)) "exactly 2 forms in binding vector")
  (let [form (get bindings 0)
        tst (get bindings 1)]
    `(let [temp# ~tst]
       (when temp#
         (let [~form temp#]
           ~@body)))))

; TODO: Macro arities
;(defmacro if-some
;  "bindings => binding-form test
;
;   If test is not nil, evaluates then with binding-form bound to the
;   value of test, if not, yields else"
;  {:added "1.6"}
;  ([bindings then]
;   `(if-some ~bindings ~then nil))
;  ([bindings then else & oldform]
;   (assert-macro-args
;     (vector? bindings) "a vector for its binding"
;     (nil? oldform) "1 or 2 forms after binding vector"
;     (= 2 (count bindings)) "exactly 2 forms in binding vector")
;   (let [form (bindings 0) tst (bindings 1)]
;     `(let [temp# ~tst]
;        (if (nil? temp#)
;          ~else
;          (let [~form temp#]
;            ~then))))))

; bindings => binding-form test
;
; When test is not nil, evaluates body with binding-form bound to the
; value of test
(defmacro when-some [bindings & body]
  (assert-macro-args
    (vector? bindings) "a vector for its binding"
    (= 2 (count bindings)) "exactly 2 forms in binding vector")
  (let [form (get bindings 0)
        tst (get bindings 1)]
    `(let [temp# ~tst]
       (if (nil? temp#)
         nil
         (let [~form temp#]
           ~@body)))))

; WARNING: This is a low-level function. Prefer high-level macros like
; binding where ever possible.
;
; Takes a map of Var/value pairs. Binds each Var to the associated value for
; the current thread. Each call *MUST* be accompanied by a matching call to
; pop-thread-bindings wrapped in a try-finally!
;
;   (push-thread-bindings bindings)
;   (try
;     ...
;     (finally
;       (pop-thread-bindings)))
(defn push-thread-bindings [bindings]
  (native/raw "__rt_ctx.push_thread_bindings(~{ bindings }).expect_ok();"))

; Pop one set of bindings pushed with push-binding before. It is an error to
; pop bindings without pushing before.
(defn pop-thread-bindings []
  (native/raw "__rt_ctx.pop_thread_bindings().expect_ok();"))

; Get a map with the Var/value pairs which is currently in effect for the
; current thread.
(defn get-thread-bindings []
  (native/raw "__value = __rt_ctx.get_thread_bindings();"))

; binding => var-symbol init-expr
;
; Creates new bindings for the (already-existing) vars, with the
; supplied initial values, executes the exprs in an implicit do, then
; re-establishes the bindings that existed before.  The new bindings
; are made in parallel (unlike let); all init-exprs are evaluated
; before the vars are bound to their new values.
(defmacro binding [bindings & body]
  (assert-macro-args
    (vector? bindings) "a vector for its binding"
    (even? (count bindings)) "an even number of forms in binding vector")
  (let [->var-pairs (fn [var-vals ret]
                      ; TODO: loop
                      (let [vvs (seq var-vals)]
                        (if vvs
                          (recur (nnext vvs)
                                 (conj (conj ret (list 'var (first vvs))) (second vvs)))
                          (seq ret))))]
    (list* 'clojure.core/let []
           (list 'clojure.core/push-thread-bindings
                 (list* 'clojure.core/hash-map
                        (->var-pairs bindings [])))
           (list (cons 'do body)
                 (list 'clojure.core/pop-thread-bindings)))))

;; Input/output.
(defn println [& args]
  ; TODO: Move println back into here once I sort out two things:
  ; 1. Escaped strings, so I can do the space in between each
  ; 2. The linker errors showing up when using fmt::format_to here
  (native/raw "__value = jank::runtime::context::println(~{ args });"))

(defn print [o]
  (native/raw "__value = jank::runtime::context::print(~{ o });"))

;; Keywords.
(defn keyword? [o]
  (native/raw "__value = make_box(~{ o }->type == object_type::keyword)"))
(defn simple-keyword? [o]
  (native/raw "__value = make_box
               (
                 ~{ o }->type == object_type::keyword
                 && expect_object<obj::keyword>(~{ o })->sym.ns.empty()
               );"))
(defn qualified-keyword? [o]
  (native/raw "__value = make_box
               (
                 ~{ o }->type == object_type::keyword
                 && !expect_object<obj::keyword>(~{ o })->sym.ns.empty()
               );"))

; Returns a Keyword with the given namespace and name.  Do not use :
; in the keyword strings, it will be added automatically.
(defn keyword
  ([name]
   (if (keyword? name)
     name
     (native/raw "__value = __rt_ctx.intern_keyword(runtime::detail::to_string(~{ name })).expect_ok();")))
  ([ns name]
   (native/raw "__value = __rt_ctx.intern_keyword
                (
                  runtime::detail::to_string(~{ ns }),
                  runtime::detail::to_string(~{ name })
                ).expect_ok();")))

(defn simple-symbol? [o]
  (native/raw "__value = make_box
               (
                 ~{ o }->type == object_type::symbol
                 && expect_object<obj::symbol>(~{ o })->ns.empty()
               );"))
(defn qualified-symbol? [o]
  (native/raw "__value = make_box
               (
                 ~{ o }->type == object_type::symbol
                 && !expect_object<obj::symbol>(~{ o })->ns.empty()
               );"))

; Returns a Symbol with the given namespace and name. Arity-1 works
; on strings, keywords, and vars.
(defn symbol
  ([o]
   (cond
     (symbol? o) o
     (string? o) (native/raw "__value = make_box<obj::symbol>(expect_object<obj::persistent_string>(~{ o })->data);")
     (var? o) (native/raw "__value = expect_object<runtime::var>(~{ o })->name;")
     (keyword? o) (native/raw "__value = make_box<obj::symbol>(expect_object<obj::keyword>(~{ o })->sym);")
     :else (throw (ex-info :cannot-convert-to-symbol {:o o}))))
  ([ns o]
   (native/raw "__value = make_box<obj::symbol>(runtime::detail::to_string(~{ ns }), runtime::detail::to_string(~{ o }));")))

;; Sequences.
(defn iterate [f x]
  (native/raw "__value = visit_object
              (
               [=](auto const typed_f) -> object_ptr
               {
                using T = typename decltype(typed_f)::value_type;

                if constexpr(std::is_base_of_v<behavior::callable, T>)
                { return make_box<obj::iterator>(typed_f, ~{ x }); }
                else
                { ~{ (throw (ex-info :not-callable {:f f})) }; }
                },
               ~{ f }
               );"))

; TODO: integer_range
(defn range
  ([]
   (iterate inc 0))
  ([end]
   (native/raw "__value = make_box<obj::range>(~{ end });"))
  ([start end]
   (native/raw "__value = make_box<obj::range>(~{ start }, ~{ end });"))
  ([start end step]
   (native/raw "__value = make_box<obj::range>(~{ start }, ~{ end }, ~{ step });")))

; Returns a lazy sequence consisting of the result of applying f to
; the set of first items of each coll, followed by applying f to the
; set of second items in each coll, until any one of the colls is
; exhausted.  Any remaining items in other colls are ignored. Function
; f should accept number-of-colls arguments. Returns a transducer when
; no collection is provided.
(defn map
  ; TODO: Transducer
  ([f coll]
   (lazy-seq
    (when-let [s (seq coll)]
      ; TODO: Chunking support
      (cons (f (first s)) (map f (rest s))))))
  ([f c1 c2]
   (lazy-seq
    (let [s1 (seq c1)
          s2 (seq c2)]
      (when (and s1 s2)
        (cons (f (first s1) (first s2))
              (map f (rest s1) (rest s2)))))))
  ([f c1 c2 c3]
   (lazy-seq
    (let [s1 (seq c1)
          s2 (seq c2)
          s3 (seq c3)]
      (when (and  s1 s2 s3)
        (cons (f (first s1) (first s2) (first s3))
              (map f (rest s1) (rest s2) (rest s3)))))))
  ; TODO: Recursion in named fns
  #_([f c1 c2 c3 & colls]
   (let [step (fn step [cs]
                 (lazy-seq
                  (let [ss (map seq cs)]
                    (when (every? identity ss)
                      (cons (map first ss) (step (map rest ss)))))))]
     (map #(apply f %) (step (conj colls c3 c2 c1))))))

(defn take
  ; TODO: Transducer.
  ([n]
   )
  ([n coll]
   (lazy-seq
     (when (pos? n)
       (when-let [s (seq coll)]
         (cons (first s) (take (dec n) (rest s))))))))

; Returns a lazy sequence of successive items from coll while
; (pred item) returns logical true. pred must be free of side-effects.
; Returns a transducer when no collection is provided.
(defn take-while [pred coll]
  (lazy-seq
    (when-let [s (seq coll)]
      (when (pred (first s))
        (cons (first s) (take-while pred (rest s)))))))

; Returns a lazy sequence of all but the first n items in coll.
; Returns a stateful transducer when no collection is provided.
(defn drop [n coll]
  ; TODO: Transducer
  (let [step (fn [n coll]
               (let [s (seq coll)]
                 (if (and (pos? n) s)
                   (recur (dec n) (rest s))
                   s)))]
    (lazy-seq (step n coll))))

; Return a lazy sequence of all but the last n (default 1) items in coll
(defn drop-last
  ([coll] (drop-last 1 coll))
  ([n coll] (map (fn [x _] x) coll (drop n coll))))

; Returns a lazy sequence of the items in coll starting from the
; first item for which (pred item) returns logical false.  Returns a
; stateful transducer when no collection is provided.
(defn drop-while [pred coll]
  (let [step (fn [pred coll]
               (let [s (seq coll)]
                 (if (and s (pred (first s)))
                   (recur pred (rest s))
                   s)))]
    (lazy-seq (step pred coll))))

; Returns a lazy (infinite!) sequence of repetitions of the items in coll.
(defn cycle [coll]
  ; TODO: Custom cycle object
  (lazy-seq (concat coll (cycle coll))))

; Returns a lazy (infinite!, or length n if supplied) sequence of xs.
(defn repeat
  ; TODO: Custom repeat object
  ([x]
   (lazy-seq (cons x (repeat x))))
  ([n x]
   (take n (repeat x))))

; Returns a vector of [(take n coll) (drop n coll)]
(defn split-at [n coll]
  [(take n coll) (drop n coll)])

; Returns a vector of [(take-while pred coll) (drop-while pred coll)]
(defn split-with [pred coll]
  [(take-while pred coll) (drop-while pred coll)])

; Returns a lazy seq of the first item in each coll, then the second etc.
(defn interleave
  ([] ())
  ([c1] (lazy-seq c1))
  ([c1 c2]
   (lazy-seq
     (let [s1 (seq c1) s2 (seq c2)]
       (when (and s1 s2)
         (cons (first s1) (cons (first s2)
                                (interleave (rest s1) (rest s2))))))))
  ([c1 c2 & colls]
   (lazy-seq
     (let [ss (map seq (conj colls c2 c1))]
       (when (every? identity ss)
         (concat (map first ss) (apply interleave (map rest ss))))))))

; When lazy sequences are produced via functions that have side
; effects, any effects other than those needed to produce the first
; element in the seq do not occur until the seq is consumed. dorun can
; be used to force any effects. Walks through the successive nexts of
; the seq, does not retain the head and returns nil.
(defn dorun
  ([coll]
   (when-let [s (seq coll)]
     (recur (next s))))
  ([n coll]
   (when (and (seq coll) (pos? n))
     (recur (dec n) (next coll)))))

; When lazy sequences are produced via functions that have side
; effects, any effects other than those needed to produce the first
; element in the seq do not occur until the seq is consumed. doall can
; be used to force any effects. Walks through the successive nexts of
; the seq, retains the head and returns it, thus causing the entire
; seq to reside in memory at one time.
(defn doall
  ([coll]
   (dorun coll)
   coll)
  ([n coll]
   (dorun n coll)
   coll))

(defn nth
  "Returns the value at the index. get returns nil if index out of
  bounds, nth throws an exception unless not-found is supplied.  nth
  also works for strings, Java arrays, regex Matchers and Lists, and,
  in O(n) time, for sequences."
  ([coll index]
   (native/raw "__value = runtime::nth(~{ coll }, ~{ index });"))
  ([coll index not-found]
   (native/raw "__value = runtime::nth(~{ coll }, ~{ index }, ~{ not-found });")))

; Returns the nth next of coll, (seq coll) when n is 0.
(defn nthnext [coll n]
  (if (and (seq coll) (pos? n))
    (recur (next coll) (dec n))
    coll))

; Returns the nth rest of coll, coll when n is 0.
(defn nthrest [coll n]
  (let [xs (and (pos? n) (seq coll))]
    (if xs
      (recur (rest coll) (dec n))
      coll)))

; Returns a lazy sequence of lists of n items each, at offsets step
; apart. If step is not supplied, defaults to n, i.e. the partitions
; do not overlap. If a pad collection is supplied, use its elements as
; necessary to complete last partition upto n items. In case there are
; not enough padding elements, return a partition with less than n items.
(defn partition
  ([n coll]
   (partition n n coll))
  ([n step coll]
   (lazy-seq
     (when-let [s (seq coll)]
       (let [p (doall (take n s))]
         (when (= n (count p))
           (cons p (partition n step (nthrest s step))))))))
  ([n step pad coll]
   (lazy-seq
     (when-let [s (seq coll)]
       (let [p (doall (take n s))]
         (if (= n (count p))
           (cons p (partition n step pad (nthrest s step)))
           (list (take n (concat p pad)))))))))

; Returns a lazy sequence of lists like partition, but may include
; partitions with fewer than n items at the end.  Returns a stateful
; transducer when no collection is provided.
(defn partition-all
  ; TODO: Transducer
  ([n coll]
   (partition-all n n coll))
  ([n step coll]
   (lazy-seq
     (when-let [s (seq coll)]
       (let [seg (doall (take n s))]
         (cons seg (partition-all n step (nthrest s step))))))))

; Applies f to each value in coll, splitting it each time f returns a
; new value.  Returns a lazy seq of partitions.  Returns a stateful
; transducer when no collection is provided.
; TODO: Transducer
(defn partition-by [f coll]
  (lazy-seq
    (when-let [s (seq coll)]
      (let [fst (first s)
            fv (f fst)
            run (cons fst (take-while #(= fv (f %)) (next s)))]
        (cons run (partition-by f (lazy-seq (drop (count run) s))))))))

; TODO: Use loop* once it exists.
(defmacro loop [bindings & body]
  (assert-macro-args
    (vector? bindings) "a vector for its binding"
    (even? (count bindings)) "an even number of forms in binding vector")
  (let [binding-pairs (partition 2 bindings)
        syms (map first binding-pairs)
        inits (map second binding-pairs)]
    `((fn [~@syms]
        ~@body) ~@inits)))

; Returns a seq of the last n items in coll.  Depending on the type
; of coll may be no better than linear time.  For vectors, see also subvec.
(defn take-last [n coll]
  (loop [s (seq coll)
         lead (seq (drop n coll))]
    (if lead
      (recur (next s) (next lead))
      s)))

; Returns a new coll consisting of to-coll with all of the items of
; from-coll conjoined. A transducer may be supplied.
(defn into
  ([] [])
  ([to] to)
  ([to from]
   (if (transientable? to)
     (with-meta (persistent! (reduce conj! (transient to) from)) (meta to))
     (reduce conj to from)))
  ; TODO: transducer arity
  )

; Returns a vector consisting of the result of applying f to the
; set of first items of each coll, followed by applying f to the set
; of second items in each coll, until any one of the colls is
; exhausted.  Any remaining items in other colls are ignored. Function
; f should accept number-of-colls arguments.
(defn mapv
  ([f coll]
   (-> (reduce (fn [v o]
                 (conj! v (f o)))
               (transient [])
               coll)
       persistent!))
  ([f c1 c2]
   (into [] (map f c1 c2)))
  ([f c1 c2 c3]
   (into [] (map f c1 c2 c3)))
  ([f c1 c2 c3 & colls]
   (into [] (apply map f c1 c2 c3 colls))))

; Returns a vector of the items in coll for which
; (pred item) returns logical true. pred must be free of side-effects.
(defn filterv [pred coll]
  (-> (reduce (fn [v o]
                (if (pred o)
                  (conj! v o)
                  v))
              (transient [])
              coll)
      persistent!))

; Returns the result of applying concat to the result of applying map
; to f and colls. Thus function f should return a collection. Returns
; a transducer when no collections are provided
(defn mapcat
  ; TODO: Transducer.
  ([f]
   )
  ; TODO: Variadic.
  ([f coll]
   (apply concat (map f coll))))

; Returns a lazy sequence of the items in coll for which
; (pred item) returns logical true. pred must be free of side-effects.
; Returns a transducer when no collection is provided.
(defn filter
  ; TODO: other arities.
  ([pred coll]
   (lazy-seq
     (when-let [s (seq coll)]
       ; TODO: Chunking support
       (let [f (first s)
             r (rest s)]
         (if (pred f)
           (cons f (filter pred r))
           (filter pred r)))))))

; Returns a lazy sequence of the items in coll for which
; (pred item) returns logical false. pred must be free of side-effects.
; Returns a transducer when no collection is provided.
(defn remove
  ([pred]
   (filter (complement pred)))
  ([pred coll]
   (filter (complement pred) coll)))

; Takes an expression and a set of test/form pairs. Threads expr (via ->)
; through each form for which the corresponding test
; expression is true. Note that, unlike cond branching, cond-> threading does
; not short circuit after the first true test expression.
(defmacro cond-> [expr & clauses]
  (assert (even? (count clauses)))
  (let [g (gensym)
        steps (map (fn [test+step]
                     (let [test (first test+step)
                           step (second test+step)]
                       `(if ~test
                          (-> ~g ~step)
                          ~g)))
                   (partition 2 clauses))]
    `(let [~g ~expr
           ~@(interleave (repeat g) (butlast steps))]
       ~(if (empty? steps)
          g
          (last steps)))))

;; Functions.
(defn ifn? [o]
  (native/raw "__value = make_box
              (
               visit_object
               (
                [=](auto const typed_o) -> native_bool
                {
                 using T = typename decltype(typed_o)::value_type;

                 if constexpr(std::is_base_of_v<behavior::callable, T>)
                 { return true; }
                 else
                 { return false; }
                 },
                ~{ o }
                )
               );"))
(defn fn? [o]
  (native/raw "auto const fn
              (
               ~{ o }->type == object_type::native_function_wrapper
               || ~{ o }->type == object_type::jit_function
               );
              __value = make_box(fn);"))

;; Miscellaneous.
; TODO: This should be a macro.
(def assert)

(defn sleep [ms]
  (let [ms (int ms)]
    (native/raw "std::this_thread::sleep_for(std::chrono::milliseconds(~{ ms }->data));")))

; Evaluates expr and prints the time it took. Returns the value of expr.
(defmacro time [expr]
  (let [now `#(native/raw "auto const t(std::chrono::high_resolution_clock::now());
                          __value = make_box(std::chrono::duration_cast<std::chrono::nanoseconds>(t.time_since_epoch()).count());")]
    `(let [start# (~now)
           ret# ~expr
           end# (~now)]
       (println (str "Elapsed time: " (/ (- end# start#) 1000000.0) " ms"))
       ret#)))

; Temporarily redefines Vars during a call to func. Each val of
; binding-map will replace the root value of its key which must be
; a Var. After func is called with no args, the root values of all
; the Vars will be set back to their old values. These temporary
; changes will be visible in all threads. Useful for mocking out
; functions during testing.
(defn with-redefs-fn [binding-map fun]
  (let [root-bind (fn [m]
                    (doseq [kv m]
                      (native/raw "expect_object<runtime::var>(~{ (first kv) })->bind_root(~{ (second kv) });")))
        old-vals (zipmap (keys binding-map)
                         (map (fn [v]
                                (native/raw "__value = expect_object<runtime::var>(~{ v })->get_root();"))
                              (keys binding-map)))]
    (try
      (root-bind binding-map)
      (fun)
      (catch e
        (throw e))
      (finally
        (root-bind old-vals)))))

; binding => var-symbol temp-value-expr
;
; Temporarily redefines Vars while executing the body.  The
; temp-value-exprs will be evaluated and each resulting value will
; replace in parallel the root value of its Var.  After the body is
; executed, the root values of all the Vars will be set back to their
; old values.  These temporary changes will be visible in all threads.
; Useful for mocking out functions during testing.
(defmacro with-redefs [bindings & body]
  (list 'clojure.core/with-redefs-fn
        (zipmap (map (fn [v]
                       (list 'var v))
                     (take-nth 2 bindings))
                (take-nth 2 (next bindings)))
        (list* 'clojure.core/fn []
               body)))

;; jank.compiler things.
; TODO: Options, following what criterium offers.
(defn benchmark [label fun]
  (native/raw "auto const label_str(expect_object<obj::persistent_string>(~{ (str label) }));
              visit_object
              (
               [=](auto const typed_fun)
               {
                using T = typename decltype(typed_fun)::value_type;

                if constexpr(std::is_base_of_v<behavior::callable, T>)
                {
                 ankerl::nanobench::Config config;
                 //config.mTimeUnitName = TODO
                 config.mOut = &std::cout;

                 /* Larger things. */
                 config.mTimeUnit = std::chrono::milliseconds{ 1 };
                 config.mMinEpochIterations = 20;
                 config.mWarmup = 10;

                 /* Smaller things. */
                 //config.mTimeUnit = std::chrono::nanoseconds{ 1 };
                 //config.mMinEpochIterations = 1000000;
                 //config.mWarmup = 1000;

                 ankerl::nanobench::Bench().config(config).run
                 (
                  static_cast<std::string>(label_str->data),
                  [&]
                  {
                   auto const res(typed_fun->call());
                   ankerl::nanobench::doNotOptimizeAway(res);
                   }
                  );
                 }
                else
                { ~{ (throw (ex-info :not-callable {:fun fun})) }; }
                },
               ~{ fun }
               );"))

;; Extra things that usually come from Java.
(defn tan [o]
  (native/raw "__value = make_box(std::tan(runtime::detail::to_real(~{ o })));"))

(defn sqrt [o]
  (native/raw "__value = make_box(std::sqrt(runtime::detail::to_real(~{ o })));"))
(reset-meta! (var sqrt) {:arities {1 {:supports-unboxed-input? true
                                      :unboxed-output? true}}})

(defn abs [o]
  (native/raw "__value = runtime::abs(~{ o });"))
(reset-meta! (var abs) {:arities {1 {:supports-unboxed-input? true
                                     :unboxed-output? true}}})

(defn pow [x y]
  (native/raw "__value = make_box(std::pow(runtime::detail::to_real(~{ x }), runtime::detail::to_real(~{ y })));"))
(reset-meta! (var pow) {:arities {2 {:supports-unboxed-input? true
                                     :unboxed-output? true}}})

; Namespaces.
(defn in-ns [sym]
  (if (symbol? sym)
    (native/raw "__rt_ctx.current_ns_var->set(__rt_ctx.intern_ns(expect_object<obj::symbol>(sym))).expect_ok();")
    (throw "argument to in-ns must be a symbol")))

; Vars.
(defn var? [o]
  (native/raw "__value = make_box(~{ o }->type == object_type::var);"))

(defn var-get [v]
  (assert (var? v))
  (native/raw "__value = expect_object<runtime::var>(~{ v })->deref();"))

; Namespaces (again).
(defn create-ns [sym]
  (assert (symbol? sym))
  (native/raw "__value = __rt_ctx.intern_ns(expect_object<obj::symbol>(~{ sym }));"))

(defn find-ns [sym]
  (assert (symbol? sym))
  (native/raw "__value = __rt_ctx.find_ns(expect_object<obj::symbol>(~{ sym })).unwrap_or(nullptr);
               if(!__value)
               { __value = obj::nil::nil_const(); }"))

(defn remove-ns [sym]
  (assert (symbol? sym))
  (native/raw "__value = __rt_ctx.remove_ns(expect_object<obj::symbol>(~{ sym })).unwrap_or(nullptr);
               if(!__value)
               { __value = obj::nil::nil_const(); }"))

(defn the-ns [ns-or-sym]
  (if (native/raw "__value = make_box(~{ ns-or-sym }->type == object_type::ns);")
    ns-or-sym
    (let [found (find-ns ns-or-sym)]
      (if (nil? found)
        (throw (ex-info :not-an-ns-or-sym {:value ns-or-sym}))
        found))))

(defn ns-name [ns-sym]
  (let [ns (the-ns ns-sym)]
    (native/raw "__value = expect_object<runtime::ns>(~{ ns })->name;")))

(defn ns-map [ns-sym]
  (let [ns (the-ns ns-sym)]
    (native/raw "__value = expect_object<runtime::ns>(~{ ns })->get_mappings();")))

(defn ns-publics [ns-sym]
  (let [ns (the-ns ns-sym)]
    ; TODO: It may be faster to start with the whole map and dissoc.
    ; TODO: Good use case for transients.
    (reduce (fn [acc kv]
              (let [k (first kv)
                    v (second kv)]
                ; TODO: Check for visibility.
                (if (var? v)
                  (if (native/raw "__value = make_box(~{ ns } == expect_object<runtime::var>(~{ v })->n);")
                    (assoc acc k v)
                    acc)
                  acc)))
            {}
            (ns-map ns))))

(defn- libspec? [x]
  (or (symbol? x)
      (and (vector? x)
           (or (nil? (second x))
               (keyword? (second x))))))

(defn- prependss [x coll]
  (if (symbol? x)
    (cons x coll)
    (concat x coll)))

(defn- root-resource [lib]
  (str "/" (name lib)))

(defn- throw-if [pred msg]
  (when pred
    (throw (ex-info :assertion-failure {:msg msg}))))

(defn alias [alias ns-sym]
  (let [ns-obj (the-ns ns-sym)]
    (assert (symbol? alias))
    (native/raw "expect_object<ns>(~{ *ns* })->add_alias
                 (
                   expect_object<obj::symbol>(~{ alias }),
                   expect_object<ns>(~{ ns-obj })
                 ).expect_ok();")))

(defn refer [ns-sym & filters]
  (let [ns (find-ns ns-sym)
        _ (when (nil? ns)
            (throw (ex-info :unknown-namespace {:value ns-sym})))
        filters (apply hash-map filters)
        rename (or (:rename filters) {})
        exclude? (set (:exclude filters))
        sym->var (ns-publics ns)
        to-refer (if (= :all (get filters :refer))
                   (keys sym->var)
                   (or (get filters :refer) (get filters :only) (keys sym->var)))]
    ; TODO: Loop
    (reduce (fn [acc sym]
              (when (not (exclude? sym))
                (let [v (get sym->var sym)
                      sym (rename sym sym)]
                  (when (nil? v)
                    (throw (ex-info :var-does-not-exist {:value sym})))
                  (native/raw "expect_object<runtime::ns>(~{ *ns* })->refer
                              (
                               expect_object<obj::symbol>(~{ sym }),
                               expect_object<runtime::var>(~{ v })
                               ).expect_ok();"))))
            nil
            to-refer)))

(defn load [& paths]
  (if (empty? paths)
    nil
    (let [path (first paths)]
      ; TODO: Check for cyclic deps, once we have dynamic vars.
      (native/raw "__rt_ctx.load_module(runtime::detail::to_string(~{ path })).expect_ok();")
      (recur (rest paths)))))

; Loads a lib given its name. If `need-ns?`, ensures that the associated
; namespace exists after loading. If `require?`, records the load so any
; duplicate loads can be skipped.
(defn- load-one [lib need-ns? require?]
  (load (root-resource lib))
  (throw-if (and need-ns? (not (find-ns lib)))
            (str "namespace " lib " not found after loading " (root-resource lib)))
  (when require?
    nil
    ; TODO: Support this.
    ;(dosync
    ; (commute *loaded-libs* conj lib))
    ))

; Loads a lib given its name and forces a load of any libs it directly or
; indirectly loads. If need-ns, ensures that the associated namespace
; exists after loading. If require, records the load so any duplicate loads
; can be skipped.
(defn- load-all [lib need-ns? require?]
  ; TODO: Port once we have dynamic vars
  ;(dosync
  ; (commute *loaded-libs* #(reduce1 conj %1 %2)
  ;          (binding [*loaded-libs* (ref (sorted-set))]
  ;            (load-one lib need-ns require)
  ;            @*loaded-libs*)))
  nil)

; Loads a lib with options
(defn- load-lib [lib & options]
  (let [opts (apply hash-map options)
        ; TODO: Map destructuring.
        as (:as opts)
        reload (:reload opts)
        reload-all (:reload-all opts)
        require (:require opts)
        use (:use opts)
        verbose (:verbose opts)
        as-alias (:as-alias opts)
        ; TODO: Dynamic var
        ;loaded (contains? @*loaded-libs* lib)
        loaded? (native/raw "__value = make_box(__rt_ctx.module_loader.is_loaded(runtime::detail::to_string(~{ lib })));")
        need-ns? (or as use)
        load (cond reload-all load-all
                   reload load-one
                   (not loaded?) (cond need-ns? load-one
                                       as-alias (fn [lib _need _require]
                                                  (create-ns lib))
                                       :else load-one))

        filter-opts (select-keys opts [:exclude :only :rename :refer])
        undefined-on-entry? (not (find-ns lib))]
    (if load
      (try
        (load lib need-ns? require)
        (catch e
          (when undefined-on-entry?
            (remove-ns lib))
          (throw e)))
      (throw-if (and need-ns? (not (find-ns lib)))
                (str "namespace " lib " not found")))
    (when as
      (alias as lib))
    (when as-alias
      (alias as-alias lib))
    (when (or use (:refer filter-opts))
      (apply refer lib (mapcat seq filter-opts)))))

; Loads libs, interpreting libspecs, prefix lists, and flags for
; forwarding to load-lib
(defn- load-libs [& args]
  (let [flags (filter keyword? args)
        ; TODO: Implement `interleave` and `repeat`.
        ;opts (interleave flags (repeat true))
        opts (reduce (fn [acc flag]
                       (concat acc [flag true]))
                     []
                     flags)
        args (remove keyword? args)]
    (let [supported #{:as :reload :reload-all :require :use :verbose :refer :as-alias}
          unsupported (seq (remove supported flags))]
      (throw-if unsupported
                (str "Unsupported option(s) supplied: " unsupported)))
    (throw-if (not (seq args)) "Nothing specified to load")
    (doseq [arg args]
      (throw-if (not (libspec? arg)) (str "not a libspec: " arg))
      (apply load-lib (prependss arg opts)))))

(defn compile [path]
  (native/raw "__rt_ctx.compile_module(runtime::detail::to_string(~{ path })).expect_ok();"))

(defn require [& args]
  (apply load-libs :require args))

(defn use [& args]
  (apply load-libs :require :use args))

; Sets *ns* to the namespace named by name (unevaluated), creating it
; if needed. References can be zero or more of: (:refer-clojure ...)
; (:require ...) (:use ...) (:import ...) (:load ...)
; with the syntax of refer-clojure/require/use/import/load respectively.
(defmacro ns [name & references]
  (let [process-reference (fn [reference]
                            (let [kname (first reference)
                                  args (rest reference)]
                              (cons (symbol "clojure.core" (clojure.core/name kname))
                                    (map (fn [a]
                                           (list 'quote a))
                                         args))))
        refer-full-clojure? (not-any? (fn [ref]
                                        (= :refer-clojure (first ref)))
                                      references)]
    (list 'do
          (list 'clojure.core/in-ns (list 'quote name))
          ; TODO: with-loading-context
          (concat '(do) ;with-loading-context
                  (when (and (not= name 'clojure.core) refer-full-clojure?)
                    [(list 'clojure.core/refer '(quote clojure.core))])
                  (map process-reference references))
          (list 'if (list '= (list 'quote name) (list 'quote 'clojure.core))
            'nil
            (list 'let (vector 'name (list 'quote name))
              (list 'native/raw "__rt_ctx.module_loader.set_loaded(runtime::detail::to_string(~{ name }));")
              ; TODO: Dynamic vars
              ;(dosync (commute @#'*loaded-libs* conj '~name))
              'nil))
          )))

(println "Bottom of clojure.core")
